repeat task.wait() until game:IsLoaded();


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Stats = game:GetService("Stats")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local Alive = Workspace:FindFirstChild("Alive")
local Aerodynamic = false
local Aerodynamic_Time = tick()
local Last_Input = UserInputService:GetLastInputType()
local Vector2_Mouse_Location = nil
local Grab_Parry = nil
local Parry_Key = nil
local VirtualInputManager = game:GetService("VirtualInputManager")

local Remotes = {}
local Parries = 0
local disableParryUntil = 0
local abilityLastUsed = 0
local Connections_Manager = {}
local Animation = {storage = {}, current = nil, track = nil}
local Parried = false
local Closest_Entity = nil
local spectate_Enabled = false
local manualSpamSpeed = 10
local pingBased = true
local TargetSelectionMethod = ""
local proxyParryFunction
local uis = game:GetService("UserInputService")
local rs = game:GetService("ReplicatedStorage")
local camera = workspace.CurrentCamera


-- Cache services once
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer.PlayerGui
local UIS = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Camera = workspace.CurrentCamera

local ParryAuthorizationToken
local proxyParryFunction
local Remotes = {}
local Parry_Key

-- Extract ParryAuthorizationToken by scanning Hotbar.Block.Activated connections
for _, connection in pairs(getconnections(PlayerGui.Hotbar.Block.Activated)) do
    local func = connection.Function
    if func and not iscclosure(func) then
        for _, upval in pairs(getupvalues(func)) do
            if type(upval) == "function" then
                ParryAuthorizationToken = getupvalue(getupvalue(upval, 2), 17)
                if ParryAuthorizationToken then break end
            end
        end
    end
    if ParryAuthorizationToken then break end
end

-- Function to find and disable the parry function listening on TouchTapInWorld
local function getParryFunc()
    while task.wait() and not proxyParryFunction do
        for _, connection in pairs(getconnections(UIS.TouchTapInWorld)) do
            local func = connection.Function
            if func and islclosure(func) then
                local constants = getconstants(func)
                if constants[#constants] == "Enabled" then
                    proxyParryFunction = func
                    connection:Disable()
                    break
                end
            end
        end
    end
    return getupvalue(getupvalue(proxyParryFunction, 2), 2)
end

local parryFunc = getParryFunc()
local secondParryArg = getupvalue(parryFunc, 17)
local parryRemotes = {}

-- Collect RemoteEvents from parryFunc upvalues
for _, upval in pairs(getupvalues(parryFunc)) do
    if typeof(upval) == "Instance" and upval:IsA("RemoteEvent") then
        table.insert(parryRemotes, upval)
    end
end

-- Constants to ignore when searching for parry strings
local ignoredConstants = {
    xpcall = true,
    Parent = true,
    CFrame = true,
    lookAt = true,
    Origin = true,
    Length = true,
}

local parryStrings = {}

-- Extract 6-letter strings from parryFunc constants, excluding ignored ones, limit 3
for _, constant in pairs(getconstants(parryFunc)) do
    if type(constant) == "string" and #constant == 6 and not ignoredConstants[constant] and #parryStrings < 3 then
        table.insert(parryStrings, constant)
    end
end

-- Validate critical data
if not secondParryArg or #secondParryArg ~= 6 then
    warn("Invalid secondParryArg")
    return
end

if #parryStrings ~= 3 then
    warn("Failed to find exactly 3 parry strings")
    return
end

for _, str in ipairs(parryStrings) do
    if type(str) ~= "string" or #str ~= 6 then
        warn("Invalid parry string detected")
        return
    end
end

if #parryRemotes ~= 3 then
    warn("Expected 3 RemoteEvents, found " .. #parryRemotes)
    return
end

for _, remote in ipairs(parryRemotes) do
    if typeof(remote) ~= "Instance" or not remote:IsA("RemoteEvent") then
        warn("Invalid RemoteEvent in parryRemotes")
        return
    end
end

-- ==== 4th check without loop ====

local targetFunc = proxyParryFunction

if type(targetFunc) == "function" and islclosure(targetFunc) and debug.getupvalues(targetFunc) then
    local Protos = debug.getprotos(targetFunc)
    local Upvalues = debug.getupvalues(targetFunc)
    local Constants = debug.getconstants(targetFunc)

    -- Adjust #Constants to 102 if patched
    if (#Protos == 4) and (#Upvalues == 24) and (#Constants == 104) then
        Remotes[debug.getupvalue(targetFunc, 16)] = debug.getconstant(targetFunc, 62)
        Parry_Key = debug.getupvalue(targetFunc, 17)
        Remotes[debug.getupvalue(targetFunc, 18)] = debug.getconstant(targetFunc, 64)
        Remotes[debug.getupvalue(targetFunc, 19)] = debug.getconstant(targetFunc, 65)
    else
        warn("4th check conditions not met (Protos, Upvalues, or Constants count mismatch)")
    end
else
    warn("targetFunc invalid for 4th check")
end

-- Main parry function to fire remotes safely
local function parry()
    for index, remote in ipairs(parryRemotes) do
        local mousePos = UIS:GetMouseLocation()
        local playersScreenPoints = {} -- Placeholder, adjust if needed

        local success, err = pcall(function()
            remote:FireServer(
                parryStrings[index],
                secondParryArg,
                0,
                Camera.CFrame,
                playersScreenPoints,
                {mousePos.X, mousePos.Y},
                false
            )
        end)

        if not success then
            warn("Remote fire failed, attempting fallback input simulation: " .. tostring(err))
            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
            task.wait()
            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
        end
    end
end

-- parry() is ready to call when needed


local Auto_Parry = {};
Auto_Parry.Parry_Animation = function()
	local Parry_Animation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild("GrabParry");
	local Current_Sword = LocalPlayer.Character:GetAttribute("CurrentlyEquippedSword");
	if (not Current_Sword or not Parry_Animation) then
		return;
	end
	local Sword_Data = ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(Current_Sword);
	if (not Sword_Data or not Sword_Data['AnimationType']) then
		return;
	end
	for _, object in pairs(ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren()) do
		if (object.Name == Sword_Data['AnimationType']) then
			local sword_animation_type = (object:FindFirstChild("GrabParry") and "GrabParry") or "Grab";
			Parry_Animation = object[sword_animation_type];
		end
	end
	Grab_Parry = LocalPlayer.Character.Humanoid.Animator:LoadAnimation(Parry_Animation);
	Grab_Parry:Play();
end;

Auto_Parry.Play_Animation = function(animationName)
	local Animations = Animation.storage[animationName];
	if not Animations then
		return false;
	end
	local Animator = LocalPlayer.Character.Humanoid.Animator;
	if (Animation.track and Animation.track:IsA("AnimationTrack")) then
		Animation.track:Stop();
	end
	Animation.track = Animator:LoadAnimation(Animations);
	if (Animation.track and Animation.track:IsA("AnimationTrack")) then
		Animation.track:Play();
	end
	Animation.current = animationName;
end;

Auto_Parry.Get_Balls = function()
	local Balls = {};
	for _, instance in pairs(Workspace.Balls:GetChildren()) do
		if instance:GetAttribute("realBall") then
			instance.CanCollide = false;
			table.insert(Balls, instance);
		end
	end
	return Balls;
end;

Auto_Parry.Get_Ball = function()
	for _, instance in pairs(Workspace.Balls:GetChildren()) do
		if instance:GetAttribute("realBall") then
			instance.CanCollide = false;
			return instance;
		end
	end
end;

function Auto_Parry.Parry_Data()
	local Camera = workspace.CurrentCamera
	if not Camera then return {0, CFrame.new(), {}, {0, 0}} end

	local ViewportSize = Camera.ViewportSize
	local MouseLocation = (Last_Input == Enum.UserInputType.MouseButton1 or Last_Input == Enum.UserInputType.MouseButton2 or Last_Input == Enum.UserInputType.Keyboard)
		and UserInputService:GetMouseLocation()
		or Vector2.new(ViewportSize.X / 2, ViewportSize.Y / 2)

	local Used = {MouseLocation.X, MouseLocation.Y}

	if TargetSelectionMethod == "ClosestToPlayer" then
		Auto_Parry.Closest_Player()
		local targetPlayer = Closest_Entity
		if targetPlayer and targetPlayer.PrimaryPart then
			Used = targetPlayer.PrimaryPart.Position
		end
	end

	local Alive = workspace.Alive:GetChildren()
	local Events = table.create(#Alive)
	for _, v in ipairs(Alive) do
			Events[tostring(v)] = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
	end

	local pos = Camera.CFrame.Position
	local look = Camera.CFrame.LookVector
	local up = Camera.CFrame.UpVector
	local right = Camera.CFrame.RightVector

	local directions = {
		Backwards = pos - look * 10000,
		Random = Vector3.new(math.random(-3000, 3000), math.random(-3000, 3000), math.random(-3000, 3000)),
		Straight = pos + look * 10000,
		Up = pos + up * 10000,
		Right = pos + right * 10000,
		Left = pos - right * 10000
	}

	local lookTarget = directions[Auto_Parry.Parry_Type] or (pos + look * 1000)
	local DirectionCF = CFrame.new(pos, lookTarget)

	return {0, DirectionCF, Events, Used}
end
function Auto_Parry.Parry(Parry_Type)
    local Parry_Data = Auto_Parry.Parry_Data(Parry_Type)

        for Remote, Args in pairs(Remotes) do
            parry()
        end
    if Parries > 7 then
        return false
    end

    Parries = Parries + 1

    task.delay(0.495, function()
        if Parries > 0 then
            Parries = Parries - 1
        end
    end)
end


local Lerp_Radians = 0;
local Last_Warping = tick();
Auto_Parry.Linear_Interpolation = function(a, b, time_volume)
	return a + ((b - a) * time_volume);
end;
local Previous_Velocity = {};
local Curving = tick();
Auto_Parry.Is_Curved = function()
    local Ball = Auto_Parry.Get_Ball();
    if not Ball then
        return false;
    end
    local Zoomies = Ball:FindFirstChild("zoomies");
    if not Zoomies then
        return false;
    end

    local Velocity = Zoomies.VectorVelocity;
    local Ball_Direction = Velocity.Unit;
    local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit;
    local Dot = Direction:Dot(Ball_Direction);
    local Speed = Velocity.Magnitude;
    local Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude;

    if not pingBased then
        if Speed < 100 then return false end
        if Dot < 0.8 then return true end
        if Distance > 100 then return false end
        return false
    end

    local Ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue();
    local Speed_Threshold = math.min(Speed / 100, 40);
    local Angle_Threshold = 40 * math.max(Dot, 0);
    local Direction_Difference = (Ball_Direction - Velocity).Unit;
    local Direction_Similarity = Direction:Dot(Direction_Difference);
    local Dot_Difference = Dot - Direction_Similarity;
    local Dot_Threshold = 0.5 - (Ping / 975);
    local Reach_Time = (Distance / Speed) - (Ping / 1000);
    local Enough_Speed = Speed > 100;
    local Ball_Distance_Threshold = ((math.max(Ping/10,15) - math.min(Distance / 1000, 15)) + Angle_Threshold + Speed_Threshold)*(1+Ping/925)

    table.insert(Previous_Velocity, Velocity);
    if (#Previous_Velocity > 4) then
        table.remove(Previous_Velocity, 1);
    end

    if (Enough_Speed and (Reach_Time > (Ping / 10))) then
        Ball_Distance_Threshold = math.max(Ball_Distance_Threshold - 15, 15);
    end

    if (Distance < Ball_Distance_Threshold) then
        return false;
    end

    if ((tick() - Curving) < (Reach_Time / 1.5)) then
        return true;
    end

    if (Dot_Difference < Dot_Threshold) then
        return true;
    end

    local Radians = math.rad(math.asin(Dot));
    Lerp_Radians = Auto_Parry.Linear_Interpolation(Lerp_Radians, Radians, 0.8);
    if (Lerp_Radians < 0.018) then
        Last_Warping = tick();
    end

    if ((tick() - Last_Warping) < (Reach_Time / 1.5)) then
        return true;
    end

    if (#Previous_Velocity == 4) then
        local Intended_Direction_Difference = (Ball_Direction - Previous_Velocity[1].Unit).Unit;
        local Intended_Dot = Direction:Dot(Intended_Direction_Difference);
        local Intended_Dot_Difference = Dot - Intended_Dot;
        local Intended_Direction_Difference2 = (Ball_Direction - Previous_Velocity[2].Unit).Unit;
        local Intended_Dot2 = Direction:Dot(Intended_Direction_Difference2);
        local Intended_Dot_Difference2 = Dot - Intended_Dot2;

        if ((Intended_Dot_Difference < Dot_Threshold) or (Intended_Dot_Difference2 < Dot_Threshold)) then
            return true;
        end
    end

    if ((tick() - Last_Warping) < (Reach_Time / 1.5)) then
        return true;
    end
	return Dot < Dot_Threshold;
end;
Auto_Parry.Closest_Player = function()
	local Max_Distance = math.huge;
	Closest_Entity = nil;
	for _, Entity in pairs(Workspace.Alive:GetChildren()) do
		if ((tostring(Entity) ~= tostring(LocalPlayer)) and Entity.PrimaryPart) then
			local Distance = LocalPlayer:DistanceFromCharacter(Entity.PrimaryPart.Position);
			if (Distance < Max_Distance) then
				Max_Distance = Distance;
				Closest_Entity = Entity;
			end
		end
	end
	return Closest_Entity;
end;
Auto_Parry.Get_Entity_Properties = function(self)
	Auto_Parry.Closest_Player();
	if not Closest_Entity then
		return false;
	end
	local Entity_Velocity = Closest_Entity.PrimaryPart.Velocity;
	local Entity_Direction = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Unit;
	local Entity_Distance = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Magnitude;
	return {Velocity=Entity_Velocity,Direction=Entity_Direction,Distance=Entity_Distance};
end;
Auto_Parry.Get_Ball_Properties = function(self)
	local ball = Auto_Parry.Get_Ball();
	if not ball then
		return false;
	end
	local character = LocalPlayer.Character;
	if (not character or not character.PrimaryPart) then
		return false;
	end
	local ballVelocity = ball.AssemblyLinearVelocity;
	local ballDirection = (character.PrimaryPart.Position - ball.Position).Unit;
	local ballDistance = (character.PrimaryPart.Position - ball.Position).Magnitude;
	local ballDot = ballDirection:Dot(ballVelocity.Unit);
	return {Velocity=ballVelocity,Direction=ballDirection,Distance=ballDistance,Dot=ballDot};
end;
Auto_Parry.Spam_Service = function(self)
	local ball = Auto_Parry.Get_Ball();
	if not ball then
		return false;
	end
	Auto_Parry.Closest_Player();
	local spamDelay = 0;
	local spamAccuracy = 100;
	if not self.Spam_Sensitivity then
		self.Spam_Sensitivity = 50;
	end
	if not self.Ping_Based_Spam then
		self.Ping_Based_Spam = false;
	end
	local velocity = ball.AssemblyLinearVelocity;
	local speed = velocity.Magnitude;
	local direction = (LocalPlayer.Character.PrimaryPart.Position - ball.Position).Unit;
	local dot = direction:Dot(velocity.Unit);
	local targetPosition = Closest_Entity.PrimaryPart.Position;
	local targetDistance = LocalPlayer:DistanceFromCharacter(targetPosition);
	local maximumSpamDistance = self.Ping + math.min(speed / 6.5, 95);
	maximumSpamDistance = maximumSpamDistance * self.Spam_Sensitivity;
	if self.Ping_Based_Spam then
		maximumSpamDistance = maximumSpamDistance + self.Ping;
	end
	if ((self.Entity_Properties.Distance > maximumSpamDistance) or (self.Ball_Properties.Distance > maximumSpamDistance) or (targetDistance > maximumSpamDistance)) then
		return spamAccuracy;
	end
	local maximumSpeed = 5 - math.min(speed / 5, 5);
	local maximumDot = math.clamp(dot, -1, 0) * maximumSpeed;
	spamAccuracy = maximumSpamDistance - maximumDot;
	task.wait(spamDelay);
	return spamAccuracy;
end;

local visualizerEnabled = false
local visualizer = Instance.new("Part")
visualizer.Shape = Enum.PartType.Ball
visualizer.Anchored = true
visualizer.CanCollide = false
visualizer.Material = Enum.Material.ForceField
visualizer.Transparency = 0.5
visualizer.Parent = Workspace
visualizer.Size = Vector3.zero
local function calculate_visualizer_radius(ball)
	    local velocity = Ball:FindFirstChild("zoomies").VectorVelocity
	return Spamming and 25 or math.clamp((velocity / 2.4) + 10, 15, 200)
end
local function toggle_visualizer(state)
	visualizerEnabled = state
	if not state then
	  visualizer.Size = Vector3.zero  -- Hide visualizer instantly
	end
end
RunService.RenderStepped:Connect(function()
	if not visualizerEnabled then return end
	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local primaryPart = char and char.PrimaryPart
	local ball = Auto_Parry.Get_Ball()
	if not (primaryPart and ball) then
	  visualizer.Size = Vector3.zero
	  return
	end
	local target = ball:GetAttribute("target")
	local isTargetingPlayer = (target == LocalPlayer.Name)
	local radius = calculate_visualizer_radius(ball)
	visualizer.Size = Vector3.new(radius, radius, radius)
	visualizer.CFrame = primaryPart.CFrame
	visualizer.Color = Spamming and Color3.fromRGB(255, 0, 0) or isTargetingPlayer and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 255, 255) -- Red = targeted, Green = safe
end)
local Sound_Effect = true
local sound_effect_type = "DC_15X"
local CustomId = "" -- Should be set to just the numeric ID, like "1234567890"

local sound_assets = {
    DC_15X = 'rbxassetid://936447863',
    Neverlose = 'rbxassetid://8679627751',
    Minecraft = 'rbxassetid://8766809464',
    MinecraftHit2 = 'rbxassetid://8458185621',
    TeamfortressBonk = 'rbxassetid://8255306220',
    TeamfortressBell = 'rbxassetid://2868331684',
    Custom = 'empty'
}

local function PlaySound()
    if not Sound_Effect then return end

    local sound_id
    if CustomId ~= "" and sound_effect_type == "Custom" then
        sound_id = "rbxassetid://" .. CustomId
    else
        sound_id = sound_assets[sound_effect_type]
    end

    if not sound_id then return end

    local sound = Instance.new("Sound")
    sound.SoundId = sound_id
    sound.Volume = 1
    sound.PlayOnRemove = true
    sound.Parent = workspace
    sound:Destroy() -- Triggers the sound due to PlayOnRemove = true
end

task.defer(function()
    game.ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(PlaySound)
end)
function ManualSpam()

    if MauaulSpam then
        MauaulSpam:Destroy()
        MauaulSpam = nil
        return
    end


    MauaulSpam = Instance.new("ScreenGui")
    MauaulSpam.Name = "MauaulSpam"
    MauaulSpam.Parent = game:GetService("CoreGui") or game.Players.LocalPlayer:WaitForChild("PlayerGui")
    MauaulSpam.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    MauaulSpam.ResetOnSpawn = false


    local Main = Instance.new("Frame")
    Main.Name = "Main"
    Main.Parent = MauaulSpam
    Main.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Main.BorderColor3 = Color3.fromRGB(0, 0, 0)
    Main.BorderSizePixel = 0
    Main.Position = UDim2.new(0.41414836, 0, 0.404336721, 0)
    Main.Size = UDim2.new(0.227479532, 0, 0.191326529, 0)

    local UICorner = Instance.new("UICorner")
    UICorner.Parent = Main


    local IndercantorBlahblah = Instance.new("Frame")
    IndercantorBlahblah.Name = "IndercantorBlahblah"
    IndercantorBlahblah.Parent = Main
    IndercantorBlahblah.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    IndercantorBlahblah.BorderColor3 = Color3.fromRGB(0, 0, 0)
    IndercantorBlahblah.BorderSizePixel = 0
    IndercantorBlahblah.Position = UDim2.new(0.0280000009, 0, 0.0733333305, 0)
    IndercantorBlahblah.Size = UDim2.new(0.0719999969, 0, 0.119999997, 0)

    local UICorner_2 = Instance.new("UICorner")
    UICorner_2.CornerRadius = UDim.new(1, 0)
    UICorner_2.Parent = IndercantorBlahblah

    local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint.Parent = IndercantorBlahblah


    local PC = Instance.new("TextLabel")
    PC.Name = "PC"
    PC.Parent = Main
    PC.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    PC.BackgroundTransparency = 1
    PC.BorderColor3 = Color3.fromRGB(0, 0, 0)
    PC.BorderSizePixel = 0
    PC.Position = UDim2.new(0.547999978, 0, 0.826666653, 0)
    PC.Size = UDim2.new(0.451999992, 0, 0.173333332, 0)
    PC.Font = Enum.Font.Unknown
    PC.Text = "PC: E to spam"
    PC.TextColor3 = Color3.fromRGB(57, 57, 57)
    PC.TextScaled = true
    PC.TextSize = 16
    PC.TextWrapped = true

    local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
    UITextSizeConstraint.Parent = PC
    UITextSizeConstraint.MaxTextSize = 16

    local UIAspectRatioConstraint_2 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_2.Parent = PC
    UIAspectRatioConstraint_2.AspectRatio = 4.346


    local IndercanotTextBlah = Instance.new("TextButton")
    IndercanotTextBlah.Name = "IndercanotTextBlah"
    IndercanotTextBlah.Parent = Main
    IndercanotTextBlah.Active = false
    IndercanotTextBlah.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    IndercanotTextBlah.BackgroundTransparency = 1
    IndercanotTextBlah.BorderColor3 = Color3.fromRGB(0, 0, 0)
    IndercanotTextBlah.BorderSizePixel = 0
    IndercanotTextBlah.Position = UDim2.new(0.164000005, 0, 0.326666653, 0)
    IndercanotTextBlah.Selectable = false
    IndercanotTextBlah.Size = UDim2.new(0.667999983, 0, 0.346666664, 0)
    IndercanotTextBlah.Font = Enum.Font.GothamBold
    IndercanotTextBlah.Text = "Spam"
    IndercanotTextBlah.TextColor3 = Color3.fromRGB(255, 255, 255)
    IndercanotTextBlah.TextScaled = true
    IndercanotTextBlah.TextSize = 24
    IndercanotTextBlah.TextWrapped = true

    local UIGradient = Instance.new("UIGradient")
    UIGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 0)),
        ColorSequenceKeypoint.new(0.75, Color3.fromRGB(255, 0, 4)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
    })
    UIGradient.Parent = IndercanotTextBlah

    local UITextSizeConstraint_2 = Instance.new("UITextSizeConstraint")
    UITextSizeConstraint_2.Parent = IndercanotTextBlah
    UITextSizeConstraint_2.MaxTextSize = 52

    local UIAspectRatioConstraint_3 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_3.Parent = IndercanotTextBlah
    UIAspectRatioConstraint_3.AspectRatio = 3.212

    local UIAspectRatioConstraint_4 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_4.Parent = Main
    UIAspectRatioConstraint_4.AspectRatio = 1.667


    local spamConnection
    local toggleManualSpam = false
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")

    local function toggleSpam()
        toggleManualSpam = not toggleManualSpam

        if spamConnection then
            spamConnection:Disconnect()
            spamConnection = nil
        end

        if toggleManualSpam then
            spamConnection = RunService.PreSimulation:Connect(function()
                for _ = 1, manualSpamSpeed do
                    if not toggleManualSpam then
                        break
                    end
                    local success, err = pcall(function()
                       parry()
                    end)
                    if not success then
                        warn("Error in Auto_Parry.Parry:", err)
                    end
                    task.wait()
                end
            end)
        end
    end


    local button = IndercanotTextBlah
    local UIGredient = button.UIGradient
    local NeedToChange = IndercantorBlahblah

local green_Color = {
    ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 128)),
    ColorSequenceKeypoint.new(0.75, Color3.fromRGB(128, 0, 128)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 128))
}

    local red_Color = {
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 0)),
        ColorSequenceKeypoint.new(0.75, Color3.fromRGB(255, 0, 0)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
    }

    local current_Color = red_Color
    local target_Color = green_Color
    local is_Green = false
    local transition = false
    local transition_Time = 1
    local start_Time

    local function startColorTransition()
        transition = true
        start_Time = tick()
    end

    RunService.Heartbeat:Connect(function()
        if transition then
            local elapsed = tick() - start_Time
            local alpha = math.clamp(elapsed / transition_Time, 0, 1)
            local new_Color = {}

            for i = 1, #current_Color do
                local start_Color = current_Color[i].Value
                local end_Color = target_Color[i].Value
                new_Color[i] = ColorSequenceKeypoint.new(current_Color[i].Time, start_Color:Lerp(end_Color, alpha))
            end

            UIGradient.Color = ColorSequence.new(new_Color)

            if alpha >= 1 then
                transition = false
                current_Color, target_Color = target_Color, current_Color
            end
        end
    end)

    local function toggleColor()
        if not transition then
            is_Green = not is_Green

            if is_Green then
                target_Color = green_Color
                NeedToChange.BackgroundColor3 = Color3.new(0, 1, 0)
                toggleSpam()
            else
                target_Color = red_Color
                NeedToChange.BackgroundColor3 = Color3.new(1, 0, 0)
                toggleSpam()
            end

            startColorTransition()
        end
    end

    button.MouseButton1Click:Connect(toggleColor)


    local keyConnection
    keyConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.E then
            toggleColor()
        end
    end)


    MauaulSpam.Destroying:Connect(function()
        if keyConnection then
            keyConnection:Disconnect()
        end
        if spamConnection then
            spamConnection:Disconnect()
        end
    end)


    local gui = Main
    local dragging
    local dragInput
    local dragStart
    local startPos

    local function update(input)
        local delta = input.Position - dragStart
        local newPosition = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )

        local TweenService = game:GetService("TweenService")
        local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(gui, tweenInfo, {Position = newPosition})
        tween:Play()
    end

    gui.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or
           input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = gui.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    gui.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or
           input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input == dragInput then
            update(input)
        end
    end)
end

local ScreenGui = Instance.new("ScreenGui")
local ImageButton = Instance.new("ImageButton")
local UICorner = Instance.new("UICorner")


ScreenGui.Parent = game.CoreGui
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling


ImageButton.Parent = ScreenGui
ImageButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
ImageButton.BorderSizePixel = 0
ImageButton.Position = UDim2.new(0.120833337, 0, 0.0952890813, 0)
ImageButton.Size = UDim2.new(0, 50, 0, 50)
-- Fixed line: Using a valid asset ID
ImageButton.Image = "rbxassetid://10582289"
ImageButton.Draggable = true


UICorner.Parent = ImageButton


ImageButton.MouseButton1Click:Connect(function()
    game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.LeftControl, false, game)
end)

local Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/CodeE4X-dev/Library/refs/heads/main/FluentRemake.lua"))();

local Window = Fluent:CreateWindow({
    Title = "VIONYX BLADEBALL",
    SubTitle = "by Vionyx Team",
    TabWidth = 160,
    Size = UDim2.fromOffset(400, 400),
    Acrylic = false,
    Theme = "DarkPurple",
    MinimizeKey = Enum.KeyCode.LeftControl
})
local Options = Fluent.Options
local Tabs = {
    Home = Window:AddTab({Title = "Home", Icon = "home"}),
    Main = Window:AddTab({Title = "Main", Icon = "swords"}),
    Visual = Window:AddTab({Title = "Visuals", Icon = "eye"}),
    play = Window:AddTab({Title = "Misc", Icon = "bot"}),
    Far = Window:AddTab({Title = "Auto Farm", Icon = "leaf"}),
    Misc = Window:AddTab({Title = "Players", Icon = "box"}),
}
Window:SelectTab(1)


local Section = Tabs.Home:AddSection("Info")
Tabs.Home:AddButton({
    Title = "Copy Discord Link",
    Description = "Copy Into Your Clipboard",
    Callback = function()
        setclipboard('https://discord.gg/vionyx-hub')
        Fluent:Notify({
            Title = "Pwease Join our Discord",
            Content = "this is Our server where you can find our  latest scripts",
            SubContent = "",
            Duration = 10
    })
    end
})

local Section = Tabs.Home:AddSection("Credits")


Tabs.Home:AddParagraph({
    Title = [[







        












        
    Devlopers/Owners
    -v0_x0
    -Nathan 
    -Nice guy
    -wiginek
    -Isa
    -Clxty

    -Testers-
    -fufu fafa
    -noval
    ]],
    Content = "",
})





local AutoParry = Tabs.Main:AddToggle("AutoParry", {Title="Auto Parry",Default=true});
AutoParry:OnChanged(function(v)
	if v then

		Connections_Manager["Auto Parry"] = RunService.PreSimulation:Connect(function()
			local One_Ball = Auto_Parry.Get_Ball();
			local Balls = Auto_Parry.Get_Balls();
			if (not Balls or (#Balls == 0)) then
				return;
			end
			for _, Ball in pairs(Balls) do
				if not Ball then
					return;
				end
				local Zoomies = Ball:FindFirstChild("zoomies");
				if not Zoomies then
					return;
				end
				Ball:GetAttributeChangedSignal("target"):Once(function()
					Parried = false;
				end);
				if Parried then
					return;
				end
				local Ball_Target = Ball:GetAttribute("target");
				local One_Target = One_Ball and One_Ball:GetAttribute("target");
				local Velocity = Zoomies.VectorVelocity;
				local character = LocalPlayer.Character;
				if (not character or not character.PrimaryPart) then
					return;
				end
				local Distance = (character.PrimaryPart.Position - Ball.Position).Magnitude;
				local Speed = Velocity.Magnitude;
				local Ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10;
				local Parry_Accuracy = (Speed / 3.25) + Ping;
				local Curved = Auto_Parry.Is_Curved();
				if ((Ball_Target == tostring(LocalPlayer)) and Aerodynamic) then
					local Elapsed_Tornado = tick() - Aerodynamic_Time;
					if (Elapsed_Tornado > 0.6) then
						Aerodynamic_Time = tick();
						Aerodynamic = false;
					end
					return;
				end
				if ((One_Target == tostring(LocalPlayer)) and Curved) then
					return;
				end
				if ((Ball_Target == tostring(LocalPlayer)) and (Distance <= Parry_Accuracy)) then
					parry()
					Parried = true;
				end
				local Last_Parrys = tick();
				while (tick() - Last_Parrys) < 1 do
					if not Parried then
						break;
					end
					task.wait();
				end
				Parried = false;
			end
		end);
	elseif Connections_Manager["Auto Parry"] then
		Connections_Manager["Auto Parry"]:Disconnect();
		Connections_Manager["Auto Parry"] = nil;
	end
end);

local AutoSpam = Tabs.Main:AddToggle("AutoSpam", {Title="Auto Spam", Default=true})
local autoSpamCoroutine = nil
local targetPlayer = nil
local highlightStartTime = nil

-- Your IsTarget function, defined once
local function IsTarget()
    return (Player.Character and Player.Character:FindFirstChild("Highlight"))
end

AutoSpam:OnChanged(function(v)
    if v then
        if autoSpamCoroutine then
            coroutine.resume(autoSpamCoroutine, "stop")
            autoSpamCoroutine = nil
        end

        autoSpamCoroutine = coroutine.create(function(signal)
            Auto_Parry.Enabled = true
            while AutoSpam.Value and (signal ~= "stop") do
                local ball = Auto_Parry.Get_Ball()
                if ball and ball:IsDescendantOf(workspace) then
                    local zoomies = ball:FindFirstChild("zoomies")
                    if zoomies then
                        Auto_Parry.Closest_Player()
                        targetPlayer = Closest_Entity

                        if targetPlayer and targetPlayer.PrimaryPart and targetPlayer:IsDescendantOf(workspace) then
                            local playerDistance = LocalPlayer:DistanceFromCharacter(ball.Position)
                            local targetPosition = targetPlayer.PrimaryPart.Position
                            local targetDistance = LocalPlayer:DistanceFromCharacter(targetPosition)

                            if targetPlayer.Parent then
                                if ball:IsDescendantOf(workspace) and (ball.Position.Magnitude >= 1) then
                                    local ballVelocity = ball.Velocity.Magnitude
                                    local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
                                    local pingThreshold = math.clamp(ping / 10, 10, 16)
                                    local ballProperties = Auto_Parry:Get_Ball_Properties()
                                    local entityProperties = Auto_Parry:Get_Entity_Properties()

                                    local spamAccuracy = Auto_Parry.Spam_Service({
                                        Ball_Properties = ballProperties,
                                        Entity_Properties = entityProperties,
                                        Ping = pingThreshold,
                                        Spam_Sensitivity = Auto_Parry.Spam_Sensitivity,
                                        Ping_Based_Spam = Auto_Parry.Ping_Based_Spam
                                    })

                                    if IsTarget() then
                                        if not highlightStartTime then
                                            highlightStartTime = tick()
                                        end

                                        local elapsed = tick() - highlightStartTime

                                        if elapsed < 0.065 then
                                            Auto_Parry.Enabled = true
                                        else
                                            Auto_Parry.Enabled = false
                                        end
                                    else
                                        highlightStartTime = nil
                                        Auto_Parry.Enabled = true
                                    end

                                    if Auto_Parry.Enabled and (zoomies.Parent == ball) and ((playerDistance <= 30) or (targetDistance <= 30)) and (Parries > 1) then
                                        parry()
                                    end
                                else
                                    local waitTime = 0
                                    repeat
                                        task.wait()
                                        waitTime = waitTime + 0.01
                                        ball = Auto_Parry.Get_Ball()
                                    until (ball and ball:IsDescendantOf(workspace) and (ball.Position.Magnitude > 1)) or (waitTime >= 2.5)
                                end
                            end
                        end
                    end
                end
                task.wait()
            end
            Auto_Parry.Enabled = false
        end)

        coroutine.resume(autoSpamCoroutine)
    elseif autoSpamCoroutine then
        coroutine.resume(autoSpamCoroutine, "stop")
        autoSpamCoroutine = nil
        Auto_Parry.Enabled = false
    end
end)


ManualSpam()
local Toggle = Tabs.Main:AddToggle("MyToggle",
{
    Title = "Manual Spam",
    Description = "Backup For Auto Spam - i do not recommend it bcs high ping",
    Default = false,
    Callback = function()
        ManualSpam()
    end
})
local Toggle = Tabs.Main:AddToggle("MyToggle",
{
    Title = "Ping Based",
    Description = "Make The Auto Parry Become Ping Based",
    Default = true,
    Callback = function(state)
        pingBased = state
        Auto_Parry.Ping_Based_Spam = state
    end
})
local SpamSensitivitySlider = Tabs.Main:AddSlider("SpamSensitivity", {
    Title = "Spam Sensitivity",
    Description = "Adjust spam responsiveness",
    Default = 50,
    Min = 1,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        Auto_Parry.Spam_Sensitivity = Value
    end
})
local nigra = Tabs.Main:AddSlider("bru", {
    Title = "Spam Speed",
    Description = "How fast the speed of manual spam",
    Default = 5,
    Min = 1,
    Max = 20,
    Rounding = 1,
    Callback = function(Value)
manualSpamSpeed = Value
    end
})
Auto_Parry.Parry_Type = "Default"

local Dropdown = Tabs.Main:AddDropdown("Dropdown", {
    Title = "Parry Direction/Curve ",
    Description = "Select the direction for automatic parrying",
    Values = {"Random", "Backwards", "Straight", "Up", "Right", "Left"},
    Multi = false,
    Default = 3,
    Callback = function(selected)
        Auto_Parry.Parry_Type = selected
    end
})

local TargetMethodDropdown = Tabs.Main:AddDropdown("TargetMethod", {
    Title = "Target Selection",
    Values = {"ClosestToPlayer", "ClosestToCursor", "Random"},
    Default = 2,
    Multi = false,
    Callback = function(Value)
        TargetSelectionMethod = Value
        CurrentTarget = nil
    end
})
local Section = Tabs.Visual:AddSection("Hit Sound")


local Toaggle = Tabs.Visual:AddToggle("MyaToggle",
{
    Title = "Hit Sound",
    Description = "Play A Sound When U Parry",
    Default = false,
    Callback = function(state)
        Sound_Effect = state
    end
})
-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Variables
local Connections_Manager = {}
local BlackOrbSpeed = 5
local AutofarmEnabled = false
local CurrentConnection
local BallAutoFarmDistance = 10
local BallAutoFarmSpeed = 100
local currentAngle = 0

-- Function to get current character safely
local function GetCurrentCharacter()
    return LocalPlayer.Character
end

-- Function to get HumanoidRootPart safely
local function GetHumanoidRootPart()
    local character = GetCurrentCharacter()
    return character and character:FindFirstChild("HumanoidRootPart")
end

-- Section
local Section = Tabs.Far:AddSection("Black Auto Farm")

-- Black Auto Farm Toggle
local BlackAutoFarm = Tabs.Far:AddToggle("BlackAutoFarm", {
    Title = "Black Auto Farm",
    Description = "Automatically farm black orbs",
    Default = false,
    Callback = function(state)
        if state then
            Connections_Manager["Black Auto Farm"] = RunService.Heartbeat:Connect(function()
                local character = GetCurrentCharacter()
                if not character or not character.PrimaryPart then return end
                
                -- Find black orbs in the workspace
                for _, orb in pairs(workspace:GetChildren()) do
                    if orb:IsA("Part") and orb.Name:lower():find("black") and orb.Name:lower():find("orb") then
                        -- Move towards the orb
                        local direction = (orb.Position - character.PrimaryPart.Position).Unit
                        character:SetPrimaryPartCFrame(character.PrimaryPart.CFrame + direction * BlackOrbSpeed)
                        
                        -- Attempt to collect the orb
                        if (character.PrimaryPart.Position - orb.Position).Magnitude < 10 then
                            orb:Destroy()
                        end
                    end
                end
            end)
        elseif Connections_Manager["Black Auto Farm"] then
            Connections_Manager["Black Auto Farm"]:Disconnect()
            Connections_Manager["Black Auto Farm"] = nil
        end
    end
})

-- Black Orb Speed Slider
local BlackOrbSpeedSlider = Tabs.Far:AddSlider("BlackOrbSpeed", {
    Title = "Black Orb Collection Speed",
    Description = "Adjust the speed of black orb collection",
    Default = 5,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Callback = function(Value)
        BlackOrbSpeed = Value
    end
})

-- Auto Collect Toggle
local AutoCollect = Tabs.Far:AddToggle("AutoCollect", {
    Title = "Auto Collect All Items",
    Description = "Automatically collect all items in the game",
    Default = false,
    Callback = function(state)
        if state then
            Connections_Manager["Auto Collect"] = RunService.Heartbeat:Connect(function()
                local character = GetCurrentCharacter()
                if not character or not character.PrimaryPart then return end
                
                for _, item in pairs(workspace:GetChildren()) do
                    if item:IsA("BasePart") and (item.Name:lower():find("collect") or item.Name:lower():find("item") or item.Name:lower():find("orb")) then
                        local direction = (item.Position - character.PrimaryPart.Position).Unit
                        character:SetPrimaryPartCFrame(character.PrimaryPart.CFrame + direction * 3)
                        
                        if (character.PrimaryPart.Position - item.Position).Magnitude < 8 then
                            item:Destroy()
                        end
                    end
                end
            end)
        elseif Connections_Manager["Auto Collect"] then
            Connections_Manager["Auto Collect"]:Disconnect()
            Connections_Manager["Auto Collect"] = nil
        end
    end
})

-- Ball Auto Farm Toggle
local BallAutoFarmToggle = Tabs.Far:AddToggle("BallAutoFarm", {
    Title = "Ball Autofarm",
    Description = "Spin around the nearest ball at custom speed and distance",
    Default = false,
    Callback = function(state)
        AutofarmEnabled = state
        if state then
            StartAutofarm()
        else
            StopAutofarm()
        end
    end
})

-- Ball Auto Farm Distance Slider
local BallAutoFarmDistanceSlider = Tabs.Far:AddSlider("BallAutoFarmDistance", {
    Title = "Ball Autofarm Distance",
    Description = "Adjust how far from the ball you spin",
    Default = 10,
    Min = 5,
    Max = 25,
    Rounding = 0,
    Callback = function(value)
        BallAutoFarmDistance = value
    end
})

-- Ball Auto Farm Speed Slider
local BallAutoFarmSpeedSlider = Tabs.Far:AddSlider("BallAutoFarmSpeed", {
    Title = "Ball Autofarm Speed",
    Description = "Adjust how fast you spin around the ball",
    Default = 100,
    Min = 1,
    Max = 100000,
    Rounding = 1,
    Callback = function(value)
        BallAutoFarmSpeed = value
    end
})

-- Validate ball function
local function VerifyBall(Ball)
    local Balls = workspace:FindFirstChild("Balls")
    if not Balls then return false end
    
    return typeof(Ball) == "Instance"
        and Ball:IsA("BasePart")
        and Ball:IsDescendantOf(Balls)
        and Ball:GetAttribute("realBall") == true
end

-- Get closest ball function
local function GetClosestBall()
    local Balls = workspace:FindFirstChild("Balls")
    if not Balls then return nil end
    
    local HumanoidRootPart = GetHumanoidRootPart()
    if not HumanoidRootPart then return nil end
    
    local closest, minDist = nil, math.huge
    for _, ball in ipairs(Balls:GetDescendants()) do
        if VerifyBall(ball) then
            local dist = (HumanoidRootPart.Position - ball.Position).Magnitude
            if dist < minDist then
                closest = ball
                minDist = dist
            end
        end
    end
    return closest
end

-- Start Autofarm function
function StartAutofarm()
    if CurrentConnection then return end
    CurrentConnection = RunService.Heartbeat:Connect(function(dt)
        local HumanoidRootPart = GetHumanoidRootPart()
        if not HumanoidRootPart then return end
        
        local ball = GetClosestBall()
        if ball then
            currentAngle = currentAngle + (dt * BallAutoFarmSpeed)
            local center = ball.Position
            local x = (math.random() * 2 - 1) * BallAutoFarmDistance
            local z = (math.random() * 2 - 1) * BallAutoFarmDistance
            local y = (math.random() * 2 - 1) * 20

            local offset = Vector3.new(x, y, z)
            local newPos = center + offset

            HumanoidRootPart.CFrame = CFrame.new(newPos, center)
        end
    end)
end

-- Stop Autofarm function
function StopAutofarm()
    if CurrentConnection then
        CurrentConnection:Disconnect()
        CurrentConnection = nil
    end
end

-- Handle character respawning
LocalPlayer.CharacterAdded:Connect(function()
    -- Small delay to ensure character is fully loaded
    wait(1)
    
    -- Restart autofarm if it was enabled
    if AutofarmEnabled then
        StopAutofarm()
        StartAutofarm()
    end
end)

-- Add Players section to the Misc tab
local Section = Tabs.Misc:AddSection("Players")

-- Add ESP toggle
local ESP = Tabs.Misc:AddToggle("ESP", {
    Title = "Player ESP",
    Description = "See players through walls",
    Default = false,
    Callback = function(state)
        -- ESP functionality
        if state then
            Connections_Manager["ESP"] = RunService.RenderStepped:Connect(function()
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        -- Create or get ESP highlight
                        local highlight = player.Character:FindFirstChild("ESPHighlight")
                        if not highlight then
                            highlight = Instance.new("Highlight")
                            highlight.Name = "ESPHighlight"
                            highlight.FillColor = Color3.new(1, 0, 0)
                            highlight.OutlineColor = Color3.new(1, 1, 1)
                            highlight.FillTransparency = 0.5
                            highlight.OutlineTransparency = 0
                            highlight.Parent = player.Character
                        end
                    end
                end
            end)
        elseif Connections_Manager["ESP"] then
            Connections_Manager["ESP"]:Disconnect()
            Connections_Manager["ESP"] = nil
            
            -- Remove all ESP highlights
            for _, player in pairs(Players:GetPlayers()) do
                if player.Character then
                    local highlight = player.Character:FindFirstChild("ESPHighlight")
                    if highlight then
                        highlight:Destroy()
                    end
                end
            end
        end
    end
})


local players = game:GetService("Players")
local player = players.LocalPlayer

local function getNearestPlayer(character)
    local nearestPlayer = nil
    local shortestDistance = math.huge 

    for _, otherPlayer in pairs(players:GetPlayers()) do
        if otherPlayer.Character and otherPlayer.Character ~= character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (character.HumanoidRootPart.Position - otherPlayer.Character.HumanoidRootPart.Position).magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestPlayer = otherPlayer
            end
        end
    end
    return nearestPlayer
end


local Players = game:GetService("Players")
local player = Players.LocalPlayer

local DEFAULT_WALKSPEED = 32

function fost()
    local character = player.Character
    if not character then return end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not hrp or not humanoid then return end

    local nearestPlayer = nil
    local shortestDistance = math.huge
    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local otherHRP = otherPlayer.Character.HumanoidRootPart
            local distance = (hrp.Position - otherHRP.Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestPlayer = otherPlayer
            end
        end
    end

    if nearestPlayer then
        local targetPos = nearestPlayer.Character.HumanoidRootPart.Position
        local distanceToTarget = (hrp.Position - targetPos).Magnitude

        if distanceToTarget <= 10 then
            -- Stop moving by setting velocity to zero and walkspeed to 0
            local bv = hrp:FindFirstChild("AutoMoveVelocity")
            if bv then
                bv.Velocity = Vector3.new(0, 0, 0)
                bv:Destroy()
            end
            humanoid.WalkSpeed = 0
        else

            humanoid.WalkSpeed = DEFAULT_WALKSPEED
            local bv = hrp:FindFirstChild("AutoMoveVelocity") or Instance.new("BodyVelocity")
            bv.Name = "AutoMoveVelocity"
            bv.MaxForce = Vector3.new(1e5, 0, 1e5)
            bv.P = 1000
            bv.Velocity = (targetPos - hrp.Position).Unit * humanoid.WalkSpeed
            bv.Parent = hrp
        end
    end
end


local Toggle = Tabs.play:AddToggle("MyToggle",
{
    Title = "go to nearest player",
    Description = "goes to nearest player",
    Default = false,
    Callback = function(state)
_G.walk = state
while task.wait(.3) and _G.walk do
    task.wait()
    workspace.Gravity = 35
fost()
end
if _G.walk == false then 
    task.wait()
    game:GetService("Players").LocalPlayer.Character.Humanoid.WalkSpeed = 32
    workspace.Gravity = 196.2
end
    end
})


local Toggle = Tabs.play:AddToggle("MyToggle",
{
    Title = "go to ball",
    Description = "goes to ball",
    Default = false,
    Callback = function(state)
local Players = game:GetService("Players")
local player = Players.LocalPlayer

_G.goball = state

while task.wait(0.15) and _G.goball do
    task.wait()
    workspace.Gravity = 35

    local character = player.Character
    if not character then continue end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not hrp or not humanoid then continue end

    local nearestBall = nil
    local shortestDistance = math.huge
    for _, folder in ipairs({workspace.Balls, workspace.TrainingBalls}) do
        for _, ball in ipairs(folder:GetChildren()) do
            if ball:GetAttribute("realBall") then
                local distance = (hrp.Position - ball.Position).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestBall = ball
                end
            end
        end
    end

    if nearestBall then
        local bv = hrp:FindFirstChild("AutoMoveVelocity") or Instance.new("BodyVelocity")
        bv.Name = "AutoMoveVelocity"
        bv.MaxForce = Vector3.new(1e5, 0, 1e5)
        bv.P = 1000
        bv.Velocity = (nearestBall.Position - hrp.Position).Unit * (humanoid.WalkSpeed or 5)
        bv.Parent = hrp
    end
end

    end
})


local Toggle = Tabs.play:AddToggle("MyToggle",
{
    Title = "stop on target",
    Description = "anchers the player when targetted",
    Default = false,
    Callback = function(state)
_G.son = state
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local DEFAULT_WALKSPEED = 32

local function IsTarget()
    return (Player.Character and Player.Character:FindFirstChild("Highlight")) ~= nil
end
while task.wait(0.1) and _G.son do
    local character = Player.Character
    if character then
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            if IsTarget() then
                humanoid.WalkSpeed = 0
            else
                humanoid.WalkSpeed = DEFAULT_WALKSPEED
            end
        end
    end
end
    end
})


local Toggle = Tabs.play:AddToggle("MyToggle",
{
    Title = "safe platform",
    Description = "",
    Default = false,
    Callback = function(state)
_G.walk = state
while task.wait() and _G.walk do
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-291, 155, -216)
end

    end
})

-- Add Teleport to Player dropdown
local PlayerTeleport = Tabs.Misc:AddDropdown("PlayerTeleport", {
    Title = "Teleport to Player",
    Description = "Teleport to selected player",
    Values = {},
    Multi = false,
    Default = 1,
    Callback = function(selectedPlayer)
        -- Teleport functionality
        for _, player in pairs(Players:GetPlayers()) do
            if player.Name == selectedPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local character = LocalPlayer.Character
                if character and character:FindFirstChild("HumanoidRootPart") then
                    character:SetPrimaryPartCFrame(player.Character.HumanoidRootPart.CFrame)
                end
                break
            end
        end
    end
})

-- Update player list for teleport dropdown
local function UpdatePlayerList()
    local playerNames = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    PlayerTeleport:SetValues(playerNames)
end

-- Update player list when players join or leave
Players.PlayerAdded:Connect(UpdatePlayerList)
Players.PlayerRemoving:Connect(UpdatePlayerList)
UpdatePlayerList()

-- Add Kill Aura toggle
local KillAura = Tabs.Misc:AddToggle("KillAura", {
    Title = "Kill Aura",
    Description = "Automatically attack nearby players",
    Default = false,
    Callback = function(state)
        -- Kill Aura functionality
        if state then
            Connections_Manager["Kill Aura"] = RunService.Heartbeat:Connect(function()
                local character = LocalPlayer.Character
                if not character or not character.PrimaryPart then return end
                
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local distance = (character.PrimaryPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                        if distance < 15 then
                            -- Simulate attack
                            local args = {
                                [1] = player.Character
                            }
                            game:GetService("ReplicatedStorage").Remotes.DamageRemote:FireServer(unpack(args))
                        end
                    end
                end
            end)
        elseif Connections_Manager["Kill Aura"] then
            Connections_Manager["Kill Aura"]:Disconnect()
            Connections_Manager["Kill Aura"] = nil
        end
    end
})

-- Add Spectate Player dropdown
local SpectatePlayer = Tabs.Misc:AddDropdown("SpectatePlayer", {
    Title = "Spectate Player",
    Description = "View the game through another player's perspective",
    Values = {},
    Multi = false,
    Default = 1,
    Callback = function(selectedPlayer)
        -- Spectate functionality
        if spectate_Enabled then
            -- Stop spectating
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character
            spectate_Enabled = false
        end
        
        for _, player in pairs(Players:GetPlayers()) do
            if player.Name == selectedPlayer and player.Character and player.Character:FindFirstChild("Humanoid") then
                workspace.CurrentCamera.CameraSubject = player.Character.Humanoid
                spectate_Enabled = true
                break
            end
        end
    end
})

-- Update player list for spectate dropdown
local function UpdateSpectateList()
    local playerNames = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    SpectatePlayer:SetValues(playerNames)
end

-- Update spectate list when players join or leave
Players.PlayerAdded:Connect(UpdateSpectateList)
Players.PlayerRemoving:Connect(UpdateSpectateList)
UpdateSpectateList()

-- Add Stop Spectating button
local StopSpectate = Tabs.Misc:AddButton({
    Title = "Stop Spectating",
    Description = "Return to your own perspective",
    Callback = function()
        if spectate_Enabled then
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character
            spectate_Enabled = false
        end
    end
})
